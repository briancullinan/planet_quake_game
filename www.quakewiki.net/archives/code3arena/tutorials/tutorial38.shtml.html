<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>

<head>
<title>Code3Arena</title>
</head>
<body background="../images/bg.gif" bgcolor="#660000" text="white" link="#C05F00" vlink="#d16545"><script type="text/javascript">document.write('<script type="text/javascript" src="http://wrapper.gamespy.com/a?pagetype=pnh_content&amp;size=prestitial"></scr' + 'ipt>');</script>

<table width="100%" border=0 cellpadding=5 cellspacing=0 align="center" background="../images/bg.gif">
<tr>
<td width=728 height=90 align="CENTER" valign="top" bgcolor=#000000>
<center><script language="javascript" type="text/javascript"> 
document.write("<"+"script type='text/javascript' src='http://wrapper.gamespy.com/a?pagetype=pnh_content&amp;size=728x90'>"); 
document.write("<"+"/script>"); 
</script>
<noscript> 
<iframe valign=top WIDTH=728 HEIGHT=90 MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no BORDERCOLOR="#000000" SRC="http://wrapper.gamespy.com/a?pagetype=pnh_content&amp;size=728x90&amp;sizew=728&amp;sizeh=90&amp;js=false"> 
</iframe> 
</noscript> </center>
</td>
</tr>
</table>

<br>

<table width="100%" cellspacing="0" cellpadding="0" border="1" align="center" bgcolor=#000000>
<tr>
<td align="CENTER">
<img src="../images/logo.gif" width="500" height="137" border="0" alt="Code3Arena">
</td>
</tr>
</table>

<p>

<table width="100%" cellpadding=0 cellspacing=0 border=0 bgcolor="#000000">
<tr>
<td><img src="../images/ouricon.gif"></td>
<td width="100%" bgcolor=#000000>
<font face="Verdana, Arial" size="2" color="#eeeeee"><b>
<A HREF="http://www.planetquake.com/">PlanetQuake</A> |
<A HREF="http://www.planetquake.com/code3arena">Code3Arena</A> |
<A HREF="http://www.planetquake.com/code3arena/tutorials">Tutorials</A> |
<a href="tutorial37.shtml.html"><< Prev</a> |
Tutorial 38 |
<a href="tutorial39.shtml.html">Next >></a>
</b></font>
</td>
</tr>
</table>
<p>


<table width="100%" border=0 cellpadding=0 cellspacing=0 align=center bgcolor=#4B0202>
<tr>

<td valign=top bgcolor="#000000">
<table width=150 bgcolor="#000000" valign=top border=0 cellpadding=10 cellspacing=0>
<tr>
<td bgcolor=#000000 valign=top>
<p>
<a href="https://www.quakewiki.net/archives/code3arena/index.shtml"><img src="../images/minilogo.gif" width="150" height="80" border="0" alt="menu"></a>
<p>
<font face=arial color="#C05F00" size=2>
<strong>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/index.shtml">Home/News</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/modsource.shtml">ModSource</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/compilers.shtml">Compiling</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/help.shtml">Help!!!</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/submission.shtml">Submission</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/contributors.shtml">Contributors</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/staff.shtml">Staff</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/downloads.shtml">Downloads</a>
</strong>
<P>
<img src="../images/tutorials.gif" width="80" height="25" border="0" alt="Tutorials">
<font color="#C05F00" size=1>
<strong>
<BR> <a href="index.html"> < Index ></a>
<BR> 1. <a href="tutorial1.shtml.html">Mod making 101</a>
<BR> 2. <a href="tutorial2.shtml.html">Up 'n running</a>
<BR> 3. <a href="tutorial3.shtml.html">Hello, QWorld!</a>
<BR> 4. <a href="tutorial4.shtml.html">Infinite Haste</a>
<BR> 5. <a href="tutorial5.shtml.html">Armor Piercing Rails</a>
<BR> 6. <a href="tutorial6.shtml.html">Bouncing Rockets</a>
<BR> 7. <a href="tutorial7.shtml.html">Cloaking</a>
<BR> 8. <a href="tutorial8.shtml.html">Ladders</a>
<BR> 9. <a href="tutorial9.shtml.html">Favourite Server</a>
<BR> 10. <a href="tutorial10.shtml.html">Flame Thrower</a>
<BR> 11. <a href="tutorial11.shtml.html">Vortex Grenades</a>
<BR> 12. <a href="tutorial12.shtml.html">Grapple</a>
<BR> 13. <a href="tutorial13.shtml.html">Lightning Discharge</a>
<BR> 14. <a href="tutorial14.shtml.html">Locational Damage</a>
<BR> 15. <a href="tutorial15.shtml.html">Leg Shots</a>
<BR> 16. <a href="tutorial16.shtml.html">Weapon Switching</a>
<BR> 17. <a href="tutorial17.shtml.html">Scoreboard frag-rate</a>
<BR> 18. <a href="tutorial18.shtml.html">Vortex Grenades II</a>
<BR> 19. <a href="tutorial19.shtml.html">Vulnerable Missiles</a>
<BR> 20. <a href="tutorial20.shtml.html">Creating Classes</a>
<BR> 21. <a href="tutorial21.shtml.html">Scrolling Credits</a>
<BR> 22. <a href="tutorial22.shtml.html">Weapon Dropping</a>
<BR> 23. <a href="tutorial23.shtml.html">Anti-Gravity Boots</a>
<BR> 24. <a href="tutorial24.shtml.html">HUD scoreboard</a>
<BR> 25. <a href="tutorial25.shtml.html">Flashlight and laser</a>
<BR> 26. <a href="tutorial26.shtml.html">Weapon Positioning</a>
<BR> 27. <a href="tutorial27.shtml.html">Weapon Reloading</a>
<BR> 28. <a href="tutorial28.shtml.html">Progressive Zooming</a>
<BR> 29. <a href="tutorial29.shtml.html">Rotating Doors</a>
<BR> 30. <a href="tutorial30.shtml.html">Beheading (headshot!)</a>
<BR> 31. <a href="tutorial31.shtml.html">Alt Weapon Fire</a>
<BR> 32. <a href="tutorial32.shtml.html">Popup Menus I</a>
<BR> 33. <a href="tutorial33.shtml.html">Popup Menus II</a>
<BR> 34. <a href="tutorial34.shtml.html">Cluster Grenades</a>
<BR> 35. <a href="tutorial35.shtml.html">Homing Rockets</a>
<BR> 36. <a href="tutorial36.shtml.html">Spreadfire Powerup</a>
<BR> 37. <a href="tutorial37.shtml.html">Instagib gameplay</a>
<BR> 38. <a href="tutorial38.shtml.html">Accelerating rockets</a>
<BR> 39. <a href="tutorial39.shtml.html">Server only Instagib</a>
<BR> 40. <a href="tutorial40.shtml.html">Advanced Grapple Hook</a>
<BR> 41. <a href="tutorial41.shtml.html">Unlagging your mod</a>
</strong>
</font>
<p><br>
<img src="../images/articles.gif" width="80" height="25" border="0" alt="Articles">
<font color="#C05F00" size=1>
<strong>
<BR> <a href="https://www.quakewiki.net/archives/code3arena/articles/index.html"> < Index > </a>
<BR> 1. <a href="https://www.quakewiki.net/archives/code3arena/articles/article1.shtml">Entities</A>
<BR> 2. <a href="https://www.quakewiki.net/archives/code3arena/articles/article2.shtml">Vectors</A>
<BR> 3. <a href="https://www.quakewiki.net/archives/code3arena/articles/article3.shtml">Good Coding</A>
<BR> 4. <a href="https://www.quakewiki.net/archives/code3arena/articles/article4.shtml">Compilers I</A>
<BR> 5. <a href="https://www.quakewiki.net/archives/code3arena/articles/article5.shtml">Compilers II</A>
<BR> 6. <a href="https://www.quakewiki.net/archives/code3arena/articles/article6.shtml">UI Menu Primer I</A>
<BR> 7. <a href="https://www.quakewiki.net/archives/code3arena/articles/article7.shtml">UI Menu Primer II</A>
<BR> 8. <a href="https://www.quakewiki.net/archives/code3arena/articles/article8.shtml">UI Menu Primer III</A>
<BR> 9. <a href="https://www.quakewiki.net/archives/code3arena/articles/article9.shtml">QVM Communication, Cvars, commands</A>
<BR> 10. <a href="https://www.quakewiki.net/archives/code3arena/articles/article10.shtml">Metrowerks CodeWarrior</A>
<BR> 11. <a href="https://www.quakewiki.net/archives/code3arena/articles/article11.shtml">1.27g code, bugs, batch</A>
</strong>
</font>
<p>

<br>
<img src="../images/links.gif" width="80" height="25" border="0" alt="Links">
<font color="#C05F00">
<small>
<li><a href="http://www.planetquake.com/quake3/files.shtml">Quake3 Files</a>
<li><a href="http://forums.planetquake.com/">Quake3 Forums</a>
<li><a href="tutorial38.shtml.html#">Q3A Editing Message Board</a>
<li><a href="http://www.planetquake.com/quake3/hosted/editing.shtml">Quake3 Editing</a>
</small>
</font>
<p><br>
<img src="../images/feedback.gif" width="80" height="25" border="0" alt="Feedback">
<font color="#C05F00">
<small>
<li><a href="mailto:sumfuka@planetquake.com">SumFuka</A>
<li><a href="mailto:calrathan@captured.com">Calrathan</A>
<li><a href="mailto:hypothermia@planetquake.com">
<font color="#FF0000">H</font><font color="#FFFF00">y</font><font color="#CC33CC">p</font><font color="#3333FF">o</font>Thermia
</A>
<li><a href="mailto:warzone@planetquake.com">WarZone</A>
</small>
</font>
<p><br>
<p><br><br><br>
<small>Site Design by:</small>
<br>
<a href="mailto:ladyice@planetice.org,jeh@planetjeh.com"><img src="../images/icelogo_sm.jpg" width="88" height="31" border="0" align="middle" alt="ICEmosis Design"></a>
</font>
<br><br>
</td>
</tr>
</table>
</td>


<td valign=top background="../images/bg.gif">
<table width=20 cellpadding=0 cellspacing=0 border=0 background="../images/bg.gif">
<tr>
<td background="../images/bg.gif">
&nbsp;
</td>
</tr>
</table>
</td>


<td valign=top bgcolor=#000000>
<table width="100%" cellpadding=15 cellspacing=10 border=0 bgcolor=#000000 valign=top>
<tr>
<td valign=top>
<font face="Verdana, Arial" size="2" color="#eeeeee">
<center><b><font color="#C05F00" size=5>
TUTORIAL 38 - Accelerating Rockets
</font></b><br>by <b><a href="mailto:doug@enfiniti.com">Doug Hammond</A></b></center><p>
<font color="#FF0000">H</font><font color="#FFFF00">y</font><font color="#CC33CC">p</font><font color="#3333FF">o</font><font color="#FFFFFF">Thermia</font>
tells me that there have been a few requests for accelerating rockets. This helpful tutorial will show
you how to make them. While not actually too useful in a deathmatch, the accelerating rocket is a good
example of how to make your own movement types, which I'll explain a bit more about later. Using the
basics of this tutorial, it's possible to make rockets that corksrew, plasma shots that do figure eights,
and pretty much anything else you can think of, as long as you have the mathematical skills.<p>
<p>Why is it important? Providing a working movement type allows client prediction to be used.
This makes the client game much smoother, and allows a "fire and forget" type system for
projectile entities. Updates to the position of an entity no longer depend on the quality of connection
between the client and server (once the client knows the entity has been created).
<p>&nbsp;
<font color="#E07F44"><H4>
1. A bit more introduction
</H4></font>
This tutorial is a look into one of the most central functions in the game, BG_EvaluateTrajectory,
and it's sister function, BG_EvaluateTrajectoryDelta. These functions predict the position and velocity
of objects respectively in the game world. Every moving object in the game refers to these functions
every program cycle, sometimes several times.<P>
This tutorial tinkers with BG_EvaluateTrajectory to allow a new kind of object movement, which can then
be implemented into Accelerating Rockets. BG_EvaluateTrajectory has a fairly simple structure to it. It
first checks what trajectory type (trType) the object is using (TR_LINEAR for rockets, TR_GRAVITY for
grenades, TR_SINE for moving platforms, and so on...) and then predicts the object's position using an
equation specific to that type.<P>
While the coding modifications in this tutorial are reasonably light, the mathematics used are really quite
complicated. To be able to make your own movement type, you will need a decent grasp of calculus, particularly
derivitives. If you don't have a clue, you may just have to find someone who does.<P>
The bulk of modifications are made in <b>bg_misc.c</b> with one addition in <b>q_shared.h</b>, and a
couple of tweaks are made to the rocket launcher in <b>g_missile.c</b>.
<p>&nbsp;
<font color="#E07F44"><H4>
2. The Code
</H4></font>
First of all, let's have a look at the variables used in the trajectory code. Open up <b>q_shared.h</b>
and have a look at line 867. You should see something like this:
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
typedef enum {
	TR_STATIONARY,
	TR_INTERPOLATE,
	TR_LINEAR,
	TR_LINEAR_STOP,
	TR_SINE,
	TR_GRAVITY
} trType_t;
</pre></font>
These are all the avaliable trTypes in the game. TR_STATIONARY just sits there,
TR_INTERPOLATE I'm not too sure on, TR_LINEAR moves in a straight line, TR_LINEAR_STOP
moves in a straight line for a specified length of time and then stops,
TR_SINE moves backwards and forwards in a sine wave pattern and TR_GRAVITY moves
in a gravity affected arc.<P>
Before we make our first modification, I'd like to distract your attention to the next
typedef in <b>q_shared.h</b>. It looks something like this:
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
typedef struct {
	trType_t	trType;
	int		trTime;
	int		trDuration;
	vec3_t	trBase;
	vec3_t	trDelta;
} trajectory_t;
</pre></font>
These are all the object-specific variables we have to work with in BG_EvaluateTrajectory.
If you add any extra variables it causes serious errors in the running of the game, so we will have to re-use one
of the values. But more on that later. Most of these are reasonably self evident, exceptions
being trBase which is the starting point of the object and trDuration being an extra variable used only
in TR_SINE and TR_LINEAR_STOP.<P>
If any of this isn't making sense, don't worry. You'll get a better idea of what's going on
once we take a look at BG_EvaluateTrajectory. But first, we need to add our own trType to
the list. Add this line to the typedef trType_t:
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	TR_GRAVITY<font color="#ff6060">,
	TR_ACCEL</font>
} trType_t;
</pre></font>
Don't forget to add in the comma after TR_GRAVITY.<P>
Now for the guts of our modification. Open up <b>bg_misc.c</b>, and find the function
BG_EvaluateTrajectory. Look closely. Basically, the function is structured so that it
checks what trType the object is, runs the appropriate equation and then returns the
predicted position of the object. We want to add a little bit of code for the TR_ACCEL
trType. The equation we're looking for should take the object's initial velocity, multiply
it by the time since the object started moving, then add the half the acceleration times the
change in time squared. Sound complicated? This is actually a simple physics equation,
normally written like so:<P>
s = u*t + .5*a*t^2<P>
Unfortunately, because of the combination of simple numbers (time and acceleration) and
vector numbers (velocity and the final result), we can't just put this equation into
the code without getting serious errors. This means we'll need to use some of quake 3's
in built vector math equations. First we need an extra variable in the function for
the missile's direction. Go to the start of the function and put this in:
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	float		deltaTime;
	float		phase;
<font color="#ff6060">	vec3_t		dir;</font>

	switch( tr->trType ) {
</pre></font>
Now we can start with our equation. At near the end of the function, put this in:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
case TR_GRAVITY:
	deltaTime = ( atTime - tr->trTime ) * 0.001;
	VectorMA( tr->trBase, deltaTime, tr->trDelta, result );
	result[2] -= 0.5 * DEFAULT_GRAVITY * deltaTime * deltaTime;
	break;<font color="#ff6060">
case TR_ACCEL:
	// time since missile fired in seconds
	deltaTime = ( atTime - tr->trTime ) * 0.001;

	// the .5*a*t^2 part. trDuration = acceleration,
	// phase gives the magnitude of the distance
	// we need to move
	phase = (tr->trDuration / 2) * (deltaTime * deltaTime);

	// Make dir equal to the velocity of the object
	VectorCopy (tr->trDelta, dir);

	// Sets the magnitude of vector dir to 1
	VectorNormalize (dir);

	// Move a distance "phase" in the direction "dir"
	// from our starting point
	VectorMA (tr->trBase, phase, dir, result);

	// The u*t part. Adds the velocity of the object
	// multiplied by the time to the last result.
	VectorMA (result, deltaTime, tr->trDelta, result);
	break;</font>
default:
	Com_Error( ERR_DROP,
		"BG_EvaluateTrajectory: unknown trType: %i", 
		tr->trTime );
</pre></font>
Quake also needs to be able to find the velocity of the object at any given time, and
so uses the aforementioned sister function BG_EvaluateTrajectoryDelta. If you take a look at it,
you'll find it works in much the same way as BG_EvaluateTrajectory. The equation for
TR_ACCEL's velocity is the initial velocity of the object plus the acceleration multiplied
by the time, or:<P>
v = u + a*t<P>
To cut a long story short, the end result of the function should look something like this:
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
/*
================
BG_EvaluateTrajectoryDelta

For determining velocity at a given time
================
*/
void BG_EvaluateTrajectoryDelta
		(const trajectory_t *tr,
		int atTime,vec3_t result ){
	float	deltaTime;
	float	phase;<font color="#ff6060">
	vec3_t	dir;</font>

	switch( tr->trType ) {
	case TR_STATIONARY:
	case TR_INTERPOLATE:
		VectorClear( result );
		break;
	case TR_LINEAR:
		VectorCopy( tr->trDelta, result );
		break;
	case TR_SINE:
		deltaTime = ( atTime - tr->trTime ) / 
			(float) tr->trDuration;
		phase = cos( deltaTime * M_PI * 2 );
		phase *= 0.5;
		VectorScale( tr->trDelta, phase, result );
		break;
	case TR_LINEAR_STOP:
		if ( atTime > tr->trTime + tr->trDuration ) {
			VectorClear( result );
			return;
		}
		VectorCopy( tr->trDelta, result );
		break;
	case TR_GRAVITY:
		deltaTime = ( atTime - tr->trTime ) * 0.001;
		VectorCopy( tr->trDelta, result );
		result[2] -= DEFAULT_GRAVITY * deltaTime;
		break;<font color="#ff6060">
	case TR_ACCEL:
		// time since missile fired in seconds
		deltaTime = ( atTime - tr->trTime ) * 0.001;

		// Turn magnitude of acceleration into a vector
		VectorCopy(tr->trDelta,dir);
		VectorNormalize (dir);
		VectorScale (dir, tr->trDuration, dir);

		// u + t * a = v
		VectorMA (tr->trDelta, deltaTime, dir, result);
		break;</font>
	default:
		Com_Error( ERR_DROP,
			"BG_EvaluateTrajectoryDelta:
			unknown trType: %i",
			tr->trTime );
		break;
	}
}
</pre></font>
And that's pretty much everything you need to know to make a new trType.
Now all we need to do is implement it into the rocket launcher. Open
<b>g_missile.c</b> and look for the function fire_rocket(). Towards the bottom
you should see something like:
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	bolt->clipmask = MASK_SHOT;

	bolt->s.pos.trType = TR_LINEAR;
	bolt->s.pos.trTime = level.time - MISSILE_PRESTEP_TIME;
	VectorCopy( start, bolt->s.pos.trBase );
	VectorScale( dir, 800, bolt->s.pos.trDelta );
	SnapVector( bolt->s.pos.trDelta );
	VectorCopy (start, bolt->r.currentOrigin);

	return bolt;
</pre></font>
We need to change the trType so Quake knows to use our equation, then we
need to add an accaleration value (a.k.a. trDuration) and then lower the rocket's initial velocity.
And the end result is:
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	bolt->clipmask = MASK_SHOT;

	bolt->s.pos.trType = <font color="#ff6060">TR_ACCEL;
	bolt->s.pos.trDuration = 500;</font>
	bolt->s.pos.trTime = level.time - MISSILE_PRESTEP_TIME;
	VectorCopy( start, bolt->s.pos.trBase );
	VectorScale( dir, <font color="#ff6060">50</font>, bolt->s.pos.trDelta );
	SnapVector( bolt->s.pos.trDelta );
	VectorCopy (start, bolt->r.currentOrigin);

	return bolt;
</pre></font>
<p>You can test this by starting a map and firing a rocket while running forward.
At first you'll run faster than the rocket, then it'll overtake you with
a doppler whoosh!
<p>&nbsp;
<font color="#E07F44"><H4>
3. Problems and warnings
</H4></font>
I encountered a few problems while making this tutorial that you all might be interested in.
Firstly and most importantly, the cgame code uses the BG_EvaluateTrajectory
function heavily. Even though we didn't change anything, if you're using .qvm
files you'll need to compile cgame.qvm after making the above modifications
otherwise the game will hang every time someone fires a rocket.<P>
Another one, as I mentioned earlier, is that adding a variable to the
trajectory_t typedef causes some wierd things to happen in the game.
Try it. You'll be able to walk through doors without them opening,
weapons won't work properly, all the items on the map will be missing
and the jump pads all get mixed up and launch you in the wrong directions.
This happens because trajectory_t is used in the executable, and even though we
modify it in q_shared.h, we never recompile the executable so it can see the
changes.<P>
Finally, be careful what equations you use in BG_EvaluateTrajectory.
For example, a variation on the code we used is as follows:
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre><font color="#ff6060">case TR_ACCEL:
	deltaTime = ( atTime - tr->trTime ) * 0.001;
	speed = tr->trDelta[0] * tr->trDelta[0] 
		+ tr->trDelta[1] * tr->trDelta[1] 
		+ tr->trDelta[2] * tr->trDelta [2];
	speed = sqrt(speed);	
		//Don't forget to add speed variable at
		//the start (as float)
	phase = ((tr->trDuration / 2) * (deltaTime*deltaTime)) 
		+ (speed * deltaTime);
	VectorCopy (tr->trDelta, dir);
	VectorNormalize (dir);
	VectorMA (tr->trBase, phase, dir, result);
	break;		
</font></pre></font>
Try this. Everything on the server side works fine, but something happens with
the client game. The client side code predicts the rocket as floating in mid air
while the server game predicts the rocket as it should. Try it for yourself to
see what I mean. I think the problem is the sqrt() function.<P>
If anyone can find solutions to these problems, drop me a line 'cause I'd be interested
to know. Also, I was thinking of making a more complicated trType for use in
cluster rockets. It's also not too hard to make a bfg that bobs up and down and
sprays plasma everywhere.<P>
Any questions, comments, email me at <a href="mailto:doug@enfiniti.com">doug@enfiniti.com</a>.
<p>&nbsp;
<font color="#E07F44"><H4>
4. Addendum by <font color="#FF0000">H</font><font color="#FFFF00">y</font><font color="#CC33CC">p</font><font color="#3333FF">o</font><font color="#FFFFFF">Thermia</font>
</H4></font>
<p>The problem with the <b>sqrt()</b> method not working (described in section 3 above)
is more subtle than it first appears. It turns out that it isn't the <b>sqrt()</b>
function that's causing the problem.
<p>It's very important to have a clear idea in your mind of where data is stored
and how it's transmitted between the client and server. There are four places where
game play data can be stored:
<ol>
<li>The server Virtual Machine (VM)
<li>The server executable
<li>The client executable
<li>The client VM
</ol>
<p>Take the creation of a rocket as an example. It first exists within the server VM (1) as a data
structure initialized by <b>fire_rocket()</b>. It's not until <b>trap_LinkEntity()</b> is called that
the server executable (2) is aware of the entity.
<p>It then becomes the responsibility of the server executable to transmit information
about the entity to the client executable (3). The client VM (4) then picks up a copy
of the information about the entity. Repeatedly calling <b>trap_LinkEntity()</b> in the server will only
cause updated information to be sent to each client if the data structure itself changes.
<p>Ideally we would only like to do the following with our entity: create it, and
then destroy it only when it next interacts with the world. This is what allows the client
to &quot;move/predict&quot; the entity for us.
<p>Why does the code in section 3 not work? The data in the <b>trajectory_t</b> structure is only
linked into the server executable (2) once. The client only sees the initial value of
<b>trDelta</b> (magnitude 50, set in <b>fire_rocket()</b>). For an accelerating rocket,
<b>trDelta</b> actually represents the direction it was fired in.
<p>So how does the proper code run? It takes the time of creation for the rocket <b>trTime</b>
(which is fixed and reliable), and calculates where the rocket should be based on
the elapsed time. <b>trDelta</b> is scaled to the correct time elapsed magnitude
before use. Because this happens in the <b>bg_*</b> code, both client and server will
agree on the movement and prediction of the rocket (without transmitting any data across
the network).
<p>Should the rocket entity be re-linked with an updated <b>trDelta</b>? DEFINITELY NOT!
This would take up extra bandwidth, would arrive at the client too late to be reliable,
and destroy the &quot;fire and forget&quot; method we're trying to preserve.
<p>It's up to you to decide which parts of the <b>trajectory_t</b> need to be updated -
the less frequently the better. Idealy it should only be done when there is a
*drastic* and sharp change in a value (like an accelerating rocket bouncing off of a wall).
<p>Server movement and client prediction will only agree when the changes are localized
within the bg_* set of files. Any server side modification only will cause some degree
of prediction error, but remember that the server has the definitive view of the world.
Prediction is a gameplay assistance, not a cast iron view of the world. The server
can make changes like that.
<p>One other interesting side effect: slow moving objects have a granularity in the
direction they can be fired. This is because <b>trDelta</b> gets rounded to
integer values. Using the zoom view you can see that these accelerating
rockets might be travelling slightly off centre. A magnitude of 50 is about the smallest you
can get away with in small arenas. If you want a slow moving and accurate
entity, then you'll have to create a special movement type for the job.
<p>
</td>
</tr>
</table>

</tr>
</table>
<p>

<table width="100%" cellpadding=0 cellspacing=0 border=0 bgcolor="#000000">
<tr>
<td><img src="../images/ouricon.gif"></td>
<td width="100%" bgcolor=#000000>
<font face="Verdana, Arial" size="2" color="#eeeeee"><b>
<A HREF="http://www.planetquake.com/">PlanetQuake</A> |
<A HREF="http://www.planetquake.com/code3arena">Code3Arena</A> |
<A HREF="http://www.planetquake.com/code3arena/tutorials">Tutorials</A> |
<a href="tutorial37.shtml.html"><< Prev</a> |
Tutorial 38 |
<a href="tutorial39.shtml.html">Next >></a>
</b></font>
</td>
</tr>
</table>
<p>

</body>

</html>
