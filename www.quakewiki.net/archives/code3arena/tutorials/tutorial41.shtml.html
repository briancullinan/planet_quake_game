<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>

<head>
<title>Code3Arena</title>
</head>
<body background="../images/bg.gif" bgcolor="#660000" text="white" link="#C05F00" vlink="#d16545"><script type="text/javascript">document.write('<script type="text/javascript" src="http://wrapper.gamespy.com/a?pagetype=pnh_content&amp;size=prestitial"></scr' + 'ipt>');</script>

<table width="100%" border=0 cellpadding=5 cellspacing=0 align="center" background="../images/bg.gif">
<tr>
<td width=728 height=90 align="CENTER" valign="top" bgcolor=#000000>
<center><script language="javascript" type="text/javascript"> 
document.write("<"+"script type='text/javascript' src='http://wrapper.gamespy.com/a?pagetype=pnh_content&amp;size=728x90'>"); 
document.write("<"+"/script>"); 
</script>
<noscript> 
<iframe valign=top WIDTH=728 HEIGHT=90 MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no BORDERCOLOR="#000000" SRC="http://wrapper.gamespy.com/a?pagetype=pnh_content&amp;size=728x90&amp;sizew=728&amp;sizeh=90&amp;js=false"> 
</iframe> 
</noscript> </center>
</td>
</tr>
</table>

<br>

<table width="100%" cellspacing="0" cellpadding="0" border="1" align="center" bgcolor=#000000>
<tr>
<td align="CENTER">
<img src="../images/logo.gif" width="500" height="137" border="0" alt="Code3Arena">
</td>
</tr>
</table>

<p>

<table width="100%" cellpadding=0 cellspacing=0 border=0 bgcolor="#000000">
<tr>
<td><img src="../images/ouricon.gif"></td>
<td width="100%" bgcolor=#000000>
<font face="Verdana, Arial" size="2" color="#eeeeee"><b>
<A HREF="http://www.planetquake.com/">PlanetQuake</A> |
<A HREF="http://www.planetquake.com/code3arena">Code3Arena</A> |
<A HREF="http://www.planetquake.com/code3arena/tutorials">Tutorials</A> |
<a href="tutorial40.shtml.html">&lt;&lt; Prev</a> |
Tutorial 41 |
<a href="https://www.quakewiki.net/archives/code3arena/tutorials/tutorial42.shtml">Next &gt;&gt;</a>
</b></font>
</td>
</tr>
</table>
<p>


<table width="100%" border=0 cellpadding=0 cellspacing=0 align=center bgcolor=#4B0202>
<tr>

<td valign=top bgcolor="#000000">
<table width=150 bgcolor="#000000" valign=top border=0 cellpadding=10 cellspacing=0>
<tr>
<td bgcolor=#000000 valign=top>
<p>
<a href="https://www.quakewiki.net/archives/code3arena/index.shtml"><img src="../images/minilogo.gif" width="150" height="80" border="0" alt="menu"></a>
<p>
<font face=arial color="#C05F00" size=2>
<strong>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/index.shtml">Home/News</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/modsource.shtml">ModSource</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/compilers.shtml">Compiling</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/help.shtml">Help!!!</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/submission.shtml">Submission</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/contributors.shtml">Contributors</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/staff.shtml">Staff</a>
<LI> <a href="https://www.quakewiki.net/archives/code3arena/downloads.shtml">Downloads</a>
</strong>
<P>
<img src="../images/tutorials.gif" width="80" height="25" border="0" alt="Tutorials">
<font color="#C05F00" size=1>
<strong>
<BR> <a href="index.html"> < Index ></a>
<BR> 1. <a href="tutorial1.shtml.html">Mod making 101</a>
<BR> 2. <a href="tutorial2.shtml.html">Up 'n running</a>
<BR> 3. <a href="tutorial3.shtml.html">Hello, QWorld!</a>
<BR> 4. <a href="tutorial4.shtml.html">Infinite Haste</a>
<BR> 5. <a href="tutorial5.shtml.html">Armor Piercing Rails</a>
<BR> 6. <a href="tutorial6.shtml.html">Bouncing Rockets</a>
<BR> 7. <a href="tutorial7.shtml.html">Cloaking</a>
<BR> 8. <a href="tutorial8.shtml.html">Ladders</a>
<BR> 9. <a href="tutorial9.shtml.html">Favourite Server</a>
<BR> 10. <a href="tutorial10.shtml.html">Flame Thrower</a>
<BR> 11. <a href="tutorial11.shtml.html">Vortex Grenades</a>
<BR> 12. <a href="tutorial12.shtml.html">Grapple</a>
<BR> 13. <a href="tutorial13.shtml.html">Lightning Discharge</a>
<BR> 14. <a href="tutorial14.shtml.html">Locational Damage</a>
<BR> 15. <a href="tutorial15.shtml.html">Leg Shots</a>
<BR> 16. <a href="tutorial16.shtml.html">Weapon Switching</a>
<BR> 17. <a href="tutorial17.shtml.html">Scoreboard frag-rate</a>
<BR> 18. <a href="tutorial18.shtml.html">Vortex Grenades II</a>
<BR> 19. <a href="tutorial19.shtml.html">Vulnerable Missiles</a>
<BR> 20. <a href="tutorial20.shtml.html">Creating Classes</a>
<BR> 21. <a href="tutorial21.shtml.html">Scrolling Credits</a>
<BR> 22. <a href="tutorial22.shtml.html">Weapon Dropping</a>
<BR> 23. <a href="tutorial23.shtml.html">Anti-Gravity Boots</a>
<BR> 24. <a href="tutorial24.shtml.html">HUD scoreboard</a>
<BR> 25. <a href="tutorial25.shtml.html">Flashlight and laser</a>
<BR> 26. <a href="tutorial26.shtml.html">Weapon Positioning</a>
<BR> 27. <a href="tutorial27.shtml.html">Weapon Reloading</a>
<BR> 28. <a href="tutorial28.shtml.html">Progressive Zooming</a>
<BR> 29. <a href="tutorial29.shtml.html">Rotating Doors</a>
<BR> 30. <a href="tutorial30.shtml.html">Beheading (headshot!)</a>
<BR> 31. <a href="tutorial31.shtml.html">Alt Weapon Fire</a>
<BR> 32. <a href="tutorial32.shtml.html">Popup Menus I</a>
<BR> 33. <a href="tutorial33.shtml.html">Popup Menus II</a>
<BR> 34. <a href="tutorial34.shtml.html">Cluster Grenades</a>
<BR> 35. <a href="tutorial35.shtml.html">Homing Rockets</a>
<BR> 36. <a href="tutorial36.shtml.html">Spreadfire Powerup</a>
<BR> 37. <a href="tutorial37.shtml.html">Instagib gameplay</a>
<BR> 38. <a href="tutorial38.shtml.html">Accelerating rockets</a>
<BR> 39. <a href="tutorial39.shtml.html">Server only Instagib</a>
<BR> 40. <a href="tutorial40.shtml.html">Advanced Grapple Hook</a>
<BR> 41. <a href="tutorial41.shtml.html">Unlagging your mod</a>
</strong>
</font>
<p><br>
<img src="../images/articles.gif" width="80" height="25" border="0" alt="Articles">
<font color="#C05F00" size=1>
<strong>
<BR> <a href="https://www.quakewiki.net/archives/code3arena/articles/index.html"> < Index > </a>
<BR> 1. <a href="https://www.quakewiki.net/archives/code3arena/articles/article1.shtml">Entities</A>
<BR> 2. <a href="https://www.quakewiki.net/archives/code3arena/articles/article2.shtml">Vectors</A>
<BR> 3. <a href="https://www.quakewiki.net/archives/code3arena/articles/article3.shtml">Good Coding</A>
<BR> 4. <a href="https://www.quakewiki.net/archives/code3arena/articles/article4.shtml">Compilers I</A>
<BR> 5. <a href="https://www.quakewiki.net/archives/code3arena/articles/article5.shtml">Compilers II</A>
<BR> 6. <a href="https://www.quakewiki.net/archives/code3arena/articles/article6.shtml">UI Menu Primer I</A>
<BR> 7. <a href="https://www.quakewiki.net/archives/code3arena/articles/article7.shtml">UI Menu Primer II</A>
<BR> 8. <a href="https://www.quakewiki.net/archives/code3arena/articles/article8.shtml">UI Menu Primer III</A>
<BR> 9. <a href="https://www.quakewiki.net/archives/code3arena/articles/article9.shtml">QVM Communication, Cvars, commands</A>
<BR> 10. <a href="https://www.quakewiki.net/archives/code3arena/articles/article10.shtml">Metrowerks CodeWarrior</A>
<BR> 11. <a href="https://www.quakewiki.net/archives/code3arena/articles/article11.shtml">1.27g code, bugs, batch</A>
</strong>
</font>
<p>

<br>
<img src="../images/links.gif" width="80" height="25" border="0" alt="Links">
<font color="#C05F00">
<small>
<li><a href="http://www.planetquake.com/quake3/files.shtml">Quake3 Files</a>
<li><a href="http://forums.planetquake.com/">Quake3 Forums</a>
<li><a href="tutorial41.shtml.html#">Q3A Editing Message Board</a>
<li><a href="http://www.planetquake.com/quake3/hosted/editing.shtml">Quake3 Editing</a>
</small>
</font>
<p><br>
<img src="../images/feedback.gif" width="80" height="25" border="0" alt="Feedback">
<font color="#C05F00">
<small>
<li><a href="mailto:sumfuka@planetquake.com">SumFuka</A>
<li><a href="mailto:calrathan@captured.com">Calrathan</A>
<li><a href="mailto:hypothermia@planetquake.com">
<font color="#FF0000">H</font><font color="#FFFF00">y</font><font color="#CC33CC">p</font><font color="#3333FF">o</font>Thermia
</A>
<li><a href="mailto:warzone@planetquake.com">WarZone</A>
</small>
</font>
<p><br>
<p><br><br><br>
<small>Site Design by:</small>
<br>
<a href="mailto:ladyice@planetice.org,jeh@planetjeh.com"><img src="../images/icelogo_sm.jpg" width="88" height="31" border="0" align="middle" alt="ICEmosis Design"></a>
</font>
<br><br>
</td>
</tr>
</table>
</td>


<td valign=top background="../images/bg.gif">
<table width=20 cellpadding=0 cellspacing=0 border=0 background="../images/bg.gif">
<tr>
<td background="../images/bg.gif">
&nbsp;
</td>
</tr>
</table>
</td>


<td valign=top bgcolor=#000000>
<table width="100%" cellpadding=15 cellspacing=10 border=0 bgcolor=#000000 valign=top>
<tr>
<td valign=top>
<font face="Verdana, Arial" size="2" color="#eeeeee">
<center><b><font color="#C05F00" size=5>
Unlagging Your Mod
</font></b><br>by <b><a href="mailto:haste@planetquake.com">Neil "haste" Toronto</A></b></center><p>
This tutorial will show you how to take an existing mod and add in the lag compensation from the <a href="http://www.planetquake.com/alternatefire">Unlagged mod at Alternate Fire</a>. The compensation can't recover lost packets or reduce players' ping, but what it does, it does well. It lets HPB's use instant-hit weapons online by compensating for their lag on the server. Anyone who fires a railgun in an Unlagged mod can aim like he's in a single-player game, no matter what his ping is.<p>
If you are just starting on a mod, you can take a shortcut. <a href="mailto:haste@planetquake.com">Email me</a> and I'll send you the source for Unlagged so you can begin from there instead of from the vanilla 1.29h source. If you do that, <b>please read this tutorial anyway</b>. There are concepts in here that you will need to know so you don't end up with weird bugs. Trust me: you don't want players getting stuck inside of each other because you created an execution path that skips undoing a time shift. It's bad. Fair enough?<P>
On with the show!<P>
<font color="#E07F44"><H4>
1. LICENSING GARBAGE
</H4></font>
Code writers get automatic exclusive copyrights on their code. The exclusive right to copy, distribute, and make derivative works are the main rights. ("Exclusive" means that it's illegal for anyone else to do it.) Those are nearly useless to me, but I've got them anyway. I'm giving them up to you (not transferring) in exchange for two things:<p>
1. You credit me (Neil Toronto) somewhere visible<br>
2. You license this source with this license if you distribute this source or a derivative of this source to anyone else<p>
The first requirement is vague on purpose. I just want some recognition for the work. I'm sure you understand. And please note that the second requirement applies only to the source code. Now that that's out of the way, here are the goods.<p>
<font color="#E07F44"><H4>
2. THE CONCEPTS
</H4></font>
Yes, yes, you want to code. I've got to explain what you'll be doing first, why, and what the issues are.<p>
<h5>The Reasons</h5>
First, let's talk about inconsistency. (It's also referred to as "B.S.") Have you ever thought you dodged a rocket but been hit smack in the face anyway? Have you ever lined up a shot just perfectly and missed? Have you ever run into some other player online and been suddenly pushed to the side?<p>
It's all B.S., isn't it? Well, there's a hard truth here: <b>in any online, multiplayer game, inconsistencies are inevitable.</b> The basic problem is that packets take a while to get from one place to another, and that makes it impossible to synchronize a client with the server exactly right.<p>
Client-side prediction is one way to deal with the time difference issue. If you're pinging 200, it takes about 100ms (milliseconds) for the signal that something happened to get from the server to you. Does that mean that you see where everyone is 100ms late? (That's actually a long time - about the width of a player if he's running normally.) Actually, no. Id Software decided, when they made Q3A, that seeing exactly what's happening on the server is very important. So player positions are sent to the client as linear trajectories, and the client game <i>extrapolates</i> everyone's positions based on old data. It's pretty accurate, since players aren't really that erratic, but there are still errors involved. Those errors, and the correction of them, account for the third B.S. case I cited above.<p>
So what? Well, as a software designer, you have to decide what kind of inconsistencies you and your audience can deal with. As I said before, Id generally has decided in favor of what you <i>see</i>. Sometimes, that means that what you <i>do</i> suffers, introducing functional inconsistencies. For example, if you ping 200, line up a rail shot perfectly, and fire, you'll miss.<p>
That's where Unlagged comes in. In Unlagged, your rail shot would land, but at a small price. The algorithm described here trades some visual consistency for more functional consistency. There are many people willing to do that. Some people don't like it - but at least now we have a choice, right?<p>
<h5>How It Works</h5>
An Unlagged server keeps track of 1/2 second of player position information. When an instant-hit shot is fired, every player but the attacking player is <b>backward reconciled</b> (or "time shifted" as I like to call it) to the positions they were in when it happened on the firing client. After the hit test, they're moved back to where they should be. The net effect is that, for the duration of the hit test, every player is pretty much where the attacking player saw them when he pulled the trigger.<p>
That's it. The implementation has a lot more detail, but in a nutshell, the previous paragraph describes how it works.<p>
<h5>The Issues</h5>
Before you ask: there is <b>no</b> cheating issue. The hit tests are still done server-side, which means that we still don't trust the client to tell us when someone was hit. Doing this stuff server-side (like Half Life does) keeps us safe from those cheating idiots who like to mess it up for everyone else.<p>
The largest issue is this: though the hit tests are accurate for the attacking player, the hit tests will happen late. The target may have moved by then, or even be obscured by map geometry. Also, the firing player will see his rail trail late, and, if he pings high, it will most likely look like it missed. That's part of the trade-off. There are some things you can do on the client to correct that a bit, but at the expense of other things...<p>
Decisions, decisions. There are some very, very good things about Unlagged. First, it feels like single-player aim (with instant-hit weapons) to everyone playing, no matter what their pings are. HPB's can finally rip it up on CTF4 and DM17. (I've seen it a lot.) Second, and this is an extension of the first, every Unlagged server feels about the same, aim-wise. You can confidently practice your railing on one and your improved accuracy will transfer to every other that you join. (Heck, you can practice your railing against bots in single-player and it'll transfer.) Third, since four of the weapons are now much more useful online, the map balance is restored. All of the sudden, the lightning gun can become a point of contention in a game where everyone pings over 100.<p>
Like I said, you have to choose your inconsistencies. If this trade-off sounds okay to you, keep reading! (If you're starting a new mod that will likely only have a few servers running it, or a realism mod, or a mod with player classes, I <i>strongly</i> recommend it.) One thing I can tell you is that it was good enough for Half Life.<p>
<font color="#E07F44"><H4>
3. THE TRAILS
</H4></font>
The first thing we need is a structure to hold all of the player position history. Open up g_local.h and find the text "clientPersistant_t". Add the new stuff shown below in <font color="#ff6060">red</font>.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
} clientPersistant_t;
<font color="#ff6060">
//NT - client origin trails
#define NUM_CLIENT_TRAILS 10
typedef struct {
    vec3_t    mins, maxs;
    vec3_t    currentOrigin;
    int       time, leveltime;
} clientTrail_t;
</font>
// this structure is cleared on each ClientSpawn(),
// except for 'client->pers' and 'client->sess'
struct gclient_s {
</pre></font>
So now we've got a "clientTrail_t" structure that defines a record that can store a few vectors (bounding box extents and the current origin) and a couple of timestamps. We've got to add this to a structure...hmm... Well, which one you use depends on what you want time shifted. Just players? Have you got shootable objects that aren't players (or bots) that also move?<p>
For now, we'll assume that it's only players and bots and add it to gclient_t. Every player and bot has a gclient_t structure. So at the end of gclient_t (the structure just below the one we added), add the stuff in <font color="#ff6060">red</font>.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    int         invulnerabilityTime;
#endif

    char        *areabits;
<font color="#ff6060">
    //NT - client origin trails
    int              trailHead;
    clientTrail_t    trail[NUM_CLIENT_TRAILS];
    clientTrail_t    saved;    // used to restore after time shift</font>
};
</pre></font>
We've got an array of 10 records to store position history. There's another record for undoing the time shift ("saved"), and an integer to store the head. One of the indexes in the array has got to be the most recent record, and we'll call it the "head" since we're implementing a queue. It's a fully initialized queue where every record has a meaningful value, so we don't have to keep track of the tail.<p>
In this new array of ours, every entry represents one position for one client in one server frame. (Servers usually run at 20fps, so a frame takes 50ms. With 10 positions, we've got 1/2 second of data.) One interesting thing that we'll get into in a bit is that player movement is usually calculated multiple times per server frame. This means that we'll be overwriting the head record a few times every server frame to keep with our paradigm.<p>
Another thing we'll get to later is the timestamp accuracy. On the head record, the timestamp <i>has to be an accurate representation of the server's clock</i>. (Otherwise, we severely mess up LPB's.) For all the rest, the end time for the frame they apply to (their level.time) is the right value. The problem is that the game engine has no callback to get the server's current, exact time! (Id, you nutjobs! Tsk, tsk! :) ) We'll have to estimate the server's clock using a callback that gives us the number of milliseconds since the game started (trap_Milliseconds). We'll store it in "level" like the other time stuff. So find the "level_locals_t" structure and add the code in <font color="#ff6060">red</font>.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    int         framenum;
    int         time;                   // in msec
    int         previousTime;           // so movers can back up when blocked<font color="#ff6060">
    int         frameStartTime;         //NT - actual time frame started
</font>
    int         startTime;              // level.time the map was started
</pre></font>
One of the very first things the server does on a server frame is call G_RunFrame. This function advances all the non-player objects in a level (bots, movers, missiles, etc.). After G_RunFrame is finished, the server updates and advances players as it receives updates from them - and that's where all the player history storage and time shifting happens. So G_RunFrame sounds like a perfect place to store the current frame's starting time. Find G_RunFrame in g_main.c and add the code in <font color="#ff6060">red</font> to the very beginning of the function.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void G_RunFrame( int levelTime ) {
    int         i;
    gentity_t   *ent;
    int         msec;
    int         start, end;
<font color="#ff6060">
    //NT - store the time the frame started
    level.frameStartTime = trap_Milliseconds();
</font></pre></font>
Now we've got to store player positions. We want to do it after every command packet, and we want to do it when the player is already at his updated position. Open up g_active.c and find the function ClientThink_real. This function is called for every command packet the server receives and for every bot think. I won't go into exactly all the things it does - we just need to remember to place our storage call right. Search for the words "exact origin" and you'll find them in a comment. Then make that code look like this by adding the <font color="#ff6060">red</font> stuff.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    // NOTE: now copy the exact origin over...
    VectorCopy( ent->client->ps.origin, ent->r.currentOrigin );
<font color="#ff6060">
    //NT - store the client's new position
    G_StoreTrail( ent );
</font></pre></font>
Where is G_StoreTrail? We'll get to that right now.<p>
<font color="#E07F44"><H4>
4. THE LOGIC
</H4></font>
There are six new functions that you'll need for lag compensation:<p>
<ul>
<li>void G_StoreTrail( gentity_t *ent );
<li>void G_ResetTrail( gentity_t *ent );
<li>void G_TimeShiftClient( gentity_t *ent, int time );
<li>void G_TimeShiftAllClients( int time, gentity_t *skip );
<li>void G_UnTimeShiftClient( gentity_t *ent );
<li>void G_UnTimeShiftAllClients( gentity_t *skip );
</ul>
They're available for download here, as <a href="g_unlagged.c">g_unlagged.c</a>. You can include them in two ways: either paste them onto the end of g_client.c (which is what I did - don't paste in the #include if you do that) or add g_unlagged.c to your game project. (You'll have to edit the batch files that compile QVM's if you do that, too.) In either case, you'll also need <a href="g_unlagged.h">g_unlagged.h</a>, which contains the prototypes for the functions. If you're doing the pasting method, just copy the function prototypes from there into g_local.h. If you're adding g_unlagged.c to your project, add a '#include "g_unlagged.h"' to g_local.h.<p>
Since the code is 200-something lines long (actually, that's small, but not for a web page), I won't paste it in here. We will talk about what each function does, though.<p>
<h5>G_ResetTrail</h5>
This sets up a client history with the client standing in his current position for the last 1/2 second. It's used to initialize the history when clients spawn or go through teleporters. There are two calls to it: one in ClientBegin, and another in TeleportPlayer. Open up g_client.c and find the ClientBegin function. Locate a call to ClientSpawn, and make it look like this by adding the <font color="#ff6060">red</font> code.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    // locate ent at a spawn point
    ClientSpawn( ent );
<font color="#ff6060">
    //NT - reset the origin trails
    G_ResetTrail( ent );
    ent->client->saved.leveltime = 0;
</font></pre></font>
We're initializing right after the client has been put on a spawn point. We're also telling G_TimeShiftClient that the position information in the "saved" structure in the player's gclient_t is not valid. (That's for a different issue, but here is a good place to do it.)<p>
Open g_misc.c and find TeleportPlayer. At the end of it, add the code in <font color="#ff6060">red</font>.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    if ( player->client->sess.sessionTeam != TEAM_SPECTATOR ) {
        trap_LinkEntity (player);
    }
<font color="#ff6060">
    //NT - reset the origin trail for this player to avoid lerping in a time shift
    G_ResetTrail( player );</font>
}
</pre></font>
The reason we need to do this is that we <b>interpolate</b> between two past player positions in the time shift to put players in the <i>exact</i> position at the time of attack. (Things are more or less smooth in the client game, but not the server game.) What if one position is on one side of a teleporter, and the other position is on the other side? The so-called "exact" position is right between them. That's pretty bogus. We can fix it by reinitializing the history.<p>
If you've got other places in your mod where players can noncontiguously move from one place to another (besides in ClientBegin and TeleportPlayer), you'll need to reinitialize the history there, too.<p>
<h5>G_StoreTrail</h5>
This is going to start to get meaty.<p>
Let's put it in pseudocode. You'll want to have the actual code in front of you, too. Understand, before you read, that level.previousTime is the start time for this server frame, and level.time is the end time. (level.time is usually assumed to be "this frame's time," which is fine, but can be confusing here.) Remember that trap_Milliseconds' return value is relative to the <i>game's</i> start time, and level.time and level.previousTime are relative to the <i>level's</i> start time.
<font face="Verdana, Arial" size="3" color="#60ff60"><pre>
    if we're on a new frame {
    	make the current head's timestamp the level time
            at the end of the last frame
        create a new head record
    }

    calculate the timestamp for the head record with the following:
    if the current player is a bot {
        newtime = level.time because they only think once per server frame
    } else {
        newtime = level.previousTime + trap_Milliseconds() - level.frameStartTime
        keep newtime between level.previousTime + 1 and level.time for sanity
    }

    store the player's position in the head record
    timestamp the head record
</pre></font>
First, the non-bot time calculation gives us an accurate representation of the server's actual time, using the game time we stored in G_RunFrame.<p>
Second, you might have noticed that we update the head record's timestamp before we make a new head. This is because the time base the clients use in extrapolating other player positions is level.time. It's entirely possible for the server to get only one update from a client on a server frame, at the very beginning of it. If that happens, everyone else's representation of that player could be up to 50ms off. We're compensating for it. This is the one time that we consider what the client sees to be a little bit more important than perfect accuracy on the server.<p>
<h5>G_TimeShiftClient and G_TimeShiftAllClients</h5>
G_TimeShiftAllClients simply calls G_TimeShiftClient for every player but the one attacking. So that's out of the way already.<p>
Let's put G_TimeShiftClient in pseudocode, too. The function is passed the player to be shifted and the time to be shifted back to.
<font face="Verdana, Arial" size="3" color="#60ff60"><pre>
    constrain the time to <= level.time for sanity

    find two entries in the origin trail whose timestamps sandwich "time"
    (assume that no two adjacent trail records have the same timestamp)

    (at this point, we've either sandwiched the time, or wrapped back
        around to the head record)

    save the player's current position

    if we've sandwiched {
        figure out how close the time is to the first timestamp
            (for interpolation)
        interpolate between the two origins for the exact position
        interpolate between the bounding box extents
        relink the entity to recalculate the absolute bounding box
    } else we've wrapped {
        time shift the client back to the place specified by the tail record
        relink the entity to recalculate the absolute bounding box
    }
</pre></font>
I'm not sure what I could say to clarify it more. One thing you should be aware of is this: if your mod is doing locational damage, you'll want to save each player's viewangles as well as his position and bounding box. To interpolate between angles, use a function called LerpAngle.<p>
<h5>G_UnTimeShiftClient and G_UnTimeShiftAllClients</h5>
Another one out of the way quickly: G_UnTimeShiftAllClients calls G_UnTimeShiftClient for every player but the one attacking.<p>
A simple explanation will suffice here. G_UnTimeShiftClient simply undoes what G_TimeShiftClient did using the position information saved in G_TimeShiftClient.<p>
<font color="#E07F44"><H4>
5. THE TIME SHIFT
</H4></font>
Now it's time to code again. Woo hoo!<p>
What we want to do is time shift every player but the attacker before a hit test, and then shift them all back when it's done. There are two rules for this that <b>must be</b> strictly observed.
<ol>
<b><li>While the players are in a time-shifted state, no other processing should be going on that is expecting the players to be in their right positions.</b> If you let any processing like that in, it won't work at random times.
<b><li>No execution path should skip undoing a time shift.</b> This means no return statements between calls to G_TimeShiftAllClients and G_UnTimeShiftAllClients. It means that, if one of those calls is conditional, the other should be called under <b>exactly the same conditions</b>. If any execution path skips undoing a time shift, you'll get weird, random errors, like the one I described at the beginning of this tutorial. (Players sometimes got stuck inside of each other.)
</ol>
If you observe these rules, everything should go well. If you don't - woe, woe, woe be unto you and your mod!<p>
Why don't we shift the attacker? Because player movement on the server lags behind player movement on the client. For instance, if I'm pinging 200, it takes about 100ms for a movement command to get to the server. Therefore, my position on the server is 100ms behind where I see myself. What does this mean? Well, the general idea behind Unlagged is to put everyone in the same positions as the attacking player saw them - and by the time the server gets the attack message, the attacking player is <i>already in the position he saw himself in</i>.<p>
Now, I have no idea what your mod does or what weapons it's got, so I'm going to walk you through the four weapons that Unlagged compensates for: the shotgun, the railgun, the machinegun, and the lightning gun.
<h5>The Shotgun</h5>
This one's the easiest. Open up g_weapon.c and locate the function ShotgunPattern. After the statement that assigns oldScore, add the following <font color="#ff6060">red</font> code.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    oldScore = ent->client->ps.persistant[PERS_SCORE];
<font color="#ff6060">
    //NT - shift other clients back to the client's idea of the server
    // time to compensate for lag
    if ( g_delagHitscan.integer && ent->client &&
        !(ent->r.svFlags & SVF_BOT) ) {
        G_TimeShiftAllClients( ent->client->pers.cmd.serverTime, ent );
    }
</font></pre></font>
ent->client->pers.cmd.serverTime is the client's estimate of the server's clock at the time of attack. (usercmd_t::serverTime is sent with every packet from the client.) If someone is pinging 300, this will most likely be 150ms or so behind the server clock, since it took that long for the packet to get to the server. (Remember that the ping time is a round-trip measurement.) It's more accurate than using ping / 2, since the trip one way can take longer than a trip the other way. Besides, we want to know how long it took <i>this packet</i> to get to the server.<p>
Then, after the "for" loop that makes the shotgun pattern, add this <font color="#ff6060">red</font> code.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
        }
    }
<font color="#ff6060">
    //NT - move the clients back to their proper positions
    if ( g_delagHitscan.integer && ent->client &&
        !(ent->r.svFlags & SVF_BOT) ) {
        G_UnTimeShiftAllClients( ent );
    }</font>
}
</pre></font>
G_TimeShiftAllClients and G_UnTimeShiftAllClients are called under the same conditions: g_delagHitscan is nonzero, the attacking entity has a client structure (is a bot or a player), and the attacking entity is not a bot.<p>
That's it! The shotgun is Unlagged. You won't be able to test it yet, since we haven't defined g_delagHitscan (that's in section 6), but it'll work.<p>
<h5>The Railgun</h5>
Find the weapon_railgun_fire function. Right at the beginning, make it look like this:<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    gentity_t   *unlinkedEntities[MAX_RAIL_HITS];
<font color="#ff6060">
    //NT - shift other clients back to the client's idea of the server
    // time to compensate for lag
    if ( g_delagHitscan.integer && ent->client &&
        !(ent->r.svFlags & SVF_BOT) ) {
        G_TimeShiftAllClients( ent->client->pers.cmd.serverTime, ent );
    }
</font>
    damage = 100 * s_quadFactor;
</pre></font>
Notice that the time-shifting code here is exactly the same as the time-shifting code in ShotgunPattern. Now let's undo the time shift.<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    } while ( unlinked < MAX_RAIL_HITS );
<font color="#ff6060">
    //NT - move the clients back to their proper positions
    if ( g_delagHitscan.integer && ent->client &&
        !(ent->r.svFlags & SVF_BOT) ) {
        G_UnTimeShiftAllClients( ent );
    }
</font></pre></font>
<h5>The Machinegun</h5>
The machinegun has one tricky part: if we did it just like the other two, there would be a return statement between the G_TimeShiftAllClients and G_UnTimeShiftAllClients. <b>That's bad, remember?</b> So let's not do that.<p>
Find Bullet_Fire. We'll start it normally, with the time shift right after the variable declarations:<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    int         i, passent;
<font color="#ff6060">
    //NT - shift other clients back to the client's idea of the server
    // time to compensate for lag
    if ( g_delagHitscan.integer && ent->client &&
        !(ent->r.svFlags & SVF_BOT) ) {
        G_TimeShiftAllClients( ent->client->pers.cmd.serverTime, ent );
    }
</font></pre></font>
Then we'll undo the time shift at the end of a function, but with a slight difference:<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
        }
        break;
    }
<font color="#ff6060">
    //NT - move the clients back to their proper positions
untimeshift:
    if ( g_delagHitscan.integer && ent->client &&
        !(ent->r.svFlags & SVF_BOT) ) {
        G_UnTimeShiftAllClients( ent );
    }</font>
}</pre></font>
There's a chance you've never seen a line like "untimeshift:" before. It's a label. We're going to use it in a goto statement.<p>
"No! A goto! Those are eeeeevil! They told me that in my CS class!" you say. Well, they're not always "eeeeevil," they just are most of the time the way most people use them. Do a little programming language study (there are loads of programming languages), and you'll find that C lacks a construct that will be executed no matter what. (In Java, it's the "finally" construct.) We're building one here. As far as I know, this is the only justification for a goto statement in a C program.<p>
Find the trap_Trace call in Bullet_Fire, and make it look like this:<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
        trap_Trace (&tr, muzzle, NULL, NULL, end, passent, MASK_SHOT);
        if ( tr.surfaceFlags & SURF_NOIMPACT ) {<font color="#ff6060">
            //NT - make sure we un-time-shift the clients
            goto untimeshift;</font>
        }

        traceEnt = &g_entities[ tr.entityNum ];
</pre></font>
The goto statement replaces the return statement.<p>
<h5>The Lightning Gun</h5>
The lightning gun firing function has the same problem as Bullet_Fire. There's a return statement in the middle of it. Find the Weapon_LightningFire function, and, as always, add the time-shifting code to the beginning of it:<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
    int         damage, i, passent;
<font color="#ff6060">
    //NT - shift other clients back to the client's idea of the server
    // time to compensate for lag
    if ( g_delagHitscan.integer && ent->client &&
        !(ent->r.svFlags & SVF_BOT) ) {
        G_TimeShiftAllClients( ent->client->pers.cmd.serverTime, ent );
    }
</font></pre></font>
Then, at the end, add the version of the time shift undo with the label:<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
        }

        break;
    }
<font color="#ff6060">
    //NT - move the clients back to their proper positions
untimeshift:
    if ( g_delagHitscan.integer && ent->client &&
        !(ent->r.svFlags & SVF_BOT) ) {
        G_UnTimeShiftAllClients( ent );
    }</font>
}</pre></font>
Find the return statement, and replace it with the goto:<p>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
        if ( tr.entityNum == ENTITYNUM_NONE ) {<font color="#ff6060">
            //NT - make sure we un-time-shift the clients
            goto untimeshift;</font>
        }

        traceEnt = &g_entities[ tr.entityNum ];
</pre></font>
Voila! We're done with the time shifting. All we've got left is a few miscellaneous things...<p>
<font color="#E07F44"><H4>
6. MISCELLANY
</H4></font>
You'll need a server-side variable to turn lag compensation on and off, and another to identify the server as running Unlagged. Open up g_main.c and add this to the end of all those vmCvar_t declarations:<p>
<font face="Verdana, Arial" size="3" color="#ff6060"><pre>
//NT - new vars
vmCvar_t    g_delagHitscan;
vmCvar_t    g_unlaggedVersion;
</pre></font>
Right after that is a large structure full of server-side variable entries. Put a comma on the end of the last entry and add these lines:<p>
<font face="Verdana, Arial" size="3" color="#ff6060"><pre>
    //NT - new vars
    { &g_delagHitscan, "g_delagHitscan", "1", 0, 0, qtrue  },
    { &g_unlaggedVersion, "g_unlaggedVersion", "1.0", CVAR_ROM | 
        CVAR_SERVERINFO, 0, qtrue }
</pre></font>
Then open g_local.h and search for "vmCvar_t" - there should be a big list of them that looks like the list in g_main.c, only with the word "extern" in front of each one. Go to the end of that list, and add these two:<p>
<font face="Verdana, Arial" size="3" color="#ff6060"><pre>
//NT - new vars
extern  vmCvar_t    g_delagHitscan;
extern  vmCvar_t    g_unlaggedVersion;
</pre></font>
Please add a g_unlaggedVersion. There may be a time where you can search in game browsers for games with this info variable set, and you'll want HPB's to find your mod.
<font color="#E07F44"><H4>
7. EXTRA THINGS YOU MIGHT WANT TO DO
</H4></font>
<h5>A Message on Connect</h5>
You may want to print a nice message to your connecting clients. The place to do that is at the end of ClientConnect in g_client.c, right before the "return NULL;" statement. Here's are two commands to do it:<p>
<font face="Verdana, Arial" size="3" color="#ff6060"><pre>
    trap_SendServerCommand( clientNum, "print \"This server is Unlagged!\n\"" );
    trap_SendServerCommand( clientNum, "cp \"THIS SERVER IS UNLAGGED\n\"" );
</pre></font>
Where "clientNum" is the client's number, already defined in ClientConnect. The first statement will dump the message to the console, and the second will put the message right in the center of the client's screen for a couple of seconds.<p>
<h5>Per-player Choice</h5>
One thing that you should seriously, seriously consider is giving users the ability to individually turn off lag compensation. Some people don't like it and would rather lead their own shots, even HPB's. (They really would - I've met some.)<p>
<h5>Locational Damage</h5>
If your mod does locational damage, you'll want to store a little more than this tutorial has you do. Every player's viewangles should be stored and then interpolated like everything else in G_TimeShiftClient. You can use the LerpAngle function to interpolate between two angles measured in degrees.<p>
One thing to consider is that, in regular Quake 3, player bounding boxes are made up of coaxial planes. (That means all six sides of the bounding box are all parallel with either the XY plane, the XZ plane, or the YZ plane.) If you modify a player's r.currentAngles and do a trap_LinkEntity, the bounding box will be rotated. Whether or not you want this to happen is up to you - just make sure the behavior is consistent.<p>
<h5>Hit-test Wrapping</h5>
The astute reader will notice that there is a way to wrap hit tests in time shifts without gotos and with less duplicated code. If you want to implement it that way, go ahead. The reason I have it the way I do is that it's easier to see if I'm introducing a conflict with the time shifting if it's all in one function. There's much less tracing to find out. Also, keeping the time shift as short as possible could make it easier in the future to add code without creating a conflict. The time-shifted state is actually quite volatile, and I think the less time the server is in one, the better.<p>
<h5>Predicted Weapon Effects</h5>
Sometimes, it really bothers people to see their rail trail late and have it apparently miss when it actually hit. It's a side-effect of the lag compensation. (Maybe one day people will just call it "lag" like they do when they miss rail shots.) One thing you might do is give users an option that they can set that will predict rail trails - make them appear immediately. As it is, the client waits for the server to say that the rail trail was created.<p>
The only problem with that is that it's possible to think you squeezed off a rail shot, and then have the server tell your client that you actually died before it got the message. In that case, the rail won't actually fly, but it'll look like it did. That's a little bit of B.S., but it may be acceptable for some people.<p>
If you want to predict rail trails regardless, you may have to store on the server whether or not a player was dead at the time he fired the rail shot. Then, you can check that to see if the rail should fly. Of course, if you do that, it's possible for apparently dead people to fire railguns. More B.S. (Geez.) Most client-side lag compensation schemes have this problem.<p>
cg_trueLightning is an attempt at lag compensation, and, as such, isn't quite compatible with Unlagged. The most compatible setting is "1.0" (the shaft is supposedly aimed right at the crosshair no matter what - but it's not), and even that has some problems in Quake 3's implementation. One thing you probably <b>will</b> want to do is make it so if the server is compensating for a player's lightning lag, the lightning shaft always points at the crosshair.<p>
<h5>Unlagging Movers</h5>
It's possible to time shift movers so they're in the positions the client saw them in. There's an issue with this that I've decided is big enough to warrant not doing it myself, but you're certainly free to do so. Most players don't have much of a problem getting hit by a shot that happened 200ms ago after they've taken cover. I assumed that most players would, however, mind getting shot through a closed door.<p>
It's still your call, though. If you do movers, make sure you store r.currentAngles for just them. And you'll have to move the trail storage out of gclient_t, since movers don't have clients.<p>
<h5>Unlagging the Gauntlet</h5>
You might have noticed that, in Unlagged, the gauntlet has no lag compensation. There are two reasons for it. First, when players get close to each other, visual inconsistencies increase. For instance, it's possible for a player to gauntlet another player, and then be behind him or facing the opposite direction by the time the hit test is calculated. You sometimes see this with close shotgun battles already.<p>
Second, a gauntlet hit is checked a whole lot more than even a lightning gun hit - somewhere between 5 and 10 times more. I haven't tested what kind of hit your CPU takes on this, but I assume it's a lot more than just plain Unlagged. If you'd like to try it out, though, there's nothing stopping you.<p>
<br>Some of these extras are client-side. If you're making a server-side-only mod, you won't be able to do them.
<font color="#E07F44"><H4>
8. CREDITS
</H4></font>
There are tons of server admins and testers that I'd like to thank, but I don't know who they all are and this tutorial is long enough as it is. Thank you, thank you, thank you.<p>
There are some people I'd like to thank in particular:<p>
<ul>
<li>Bryan "Apoxol" Dube, the creator of Urban Terror's server-side lag compensation. I only found out that he had implemented it after I created Unlagged beta 1, but then we put our heads together to make both of our implementations better.
<li>Ted "Targhan" Vessenes, one of the creators of Art of War, for making me think harder and showing me a good few things that have really made Unlagged work. Indespensible.
<li>Pat "Cornholio" Winn, for being stubborn enough to stick by his story that the first few versions didn't feel right - and also for keeping an Unlagged server up to help me test.
<li>G-Man, for being patient and helping me test for hours on end in the first betas.
<li>Aaron "Paradox" Storck, for the very cool Instagib implementation, Insta-Unlagged.
</ul>
Consider yourselves thanked.<p>
<font color="#E07F44"><H4>
9. LINKS
</H4></font>
Code files: <a href="g_unlagged.c">g_unlagged.c</a>, <a href="g_unlagged.h">g_unlagged.h</a><br>
Author's email: <a href="mailto:haste@planetquake.com">haste@planetquake.com</a><br>
Author's web site: <a href="http://www.planetquake.com/alternatefire">Alternate Fire</a><p>
</font></td>
</tr>
</table>
</td></tr>
</table>

<p>

<table width="100%" cellpadding=0 cellspacing=0 border=0 bgcolor="#000000">
<tr>
<td><img src="../images/ouricon.gif"></td>
<td width="100%" bgcolor=#000000>
<font face="Verdana, Arial" size="2" color="#eeeeee"><b>
<A HREF="http://www.planetquake.com/">PlanetQuake</A> |
<A HREF="http://www.planetquake.com/code3arena">Code3Arena</A> |
<A HREF="http://www.planetquake.com/code3arena/tutorials">Tutorials</A> |
<a href="tutorial40.shtml.html">&lt;&lt; Prev</a> |
Tutorial 41 |
<a href="https://www.quakewiki.net/archives/code3arena/tutorials/tutorial42.shtml">Next &gt;&gt;</a>
</b></font>
</td>
</tr>
</table>
<p>

</body>

</html>
